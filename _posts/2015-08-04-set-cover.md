---
layout: post
title: 指纹覆盖
tag: Algorithm
---

## 描述

少写点正则一直是每个实习生的梦想。（懒～

周一Loading又发任务包了，给了一大堆的指纹，啥设备都有：`Nginx`，`Cisco SSH`，`VoIP`，`Apache httpd`，`Apache Tomcat`<br>，`Apache Traffic Server`，`Apache Traffic Server 5.3.1`，`Apache Traffic Server 5.3.10086` 等等……

实习生们又头大了，这得写多少指纹啊？ Peter是个很懒的实习生，他正在琢磨一种方法尽可能地少写指纹：已知指纹的全集 U={0,2,3...n-1}，能用作匹配的正则集合 F={S<sub>1</sub>,S<sub>2</sub>...S<sub>m</sub>} 每条正则S<sub>k</sub>能覆盖的指纹 S<sub>k</sub>为 U 的一个子集。Peter想找出一种方案，用最少数量的正则去覆盖整个指纹全集 U 。看起来很难的样子，Peter感觉自己智商捉急，任务期限又特别紧，你能帮帮他吗？

比如:
 
* U = {0,1,2,3,4,5,6,7,8,9,10,11}
* F = {S0,S1, S2, S3, S4, S5}
* S<sub>0</sub> = {0,1,2,3,4,5}, S<sub>1</sub> = {4,5,7,8} , S<sub>2</sub> = {0,3,6,9} ,　S<sub>3</sub> = {1,4,6,7,10} , S<sub>4</sub> = {2,5,8,11}, S<sub>5</sub> = {9,10}。
* 其最小的集合覆盖C={S2, S3, S4}

##输入要求
第一行有2个正整数n和m，(1 <= n <= 6000 , 1 <= m <= 600)分别表示有限集X中元素个数和子集族F中子集个数。X = {0,1,.., n -1}, F = {S1,S2 , ... ,Sm-1}。
　　接下来的m行中，每行对应F中一个子集Si。第一个数是子集Si中元素个数ki，接着的ki个数表示Si中的元素。 

##输出要求
输出第一行表示最小的覆盖数C\*,(设最优解为C，C\*在范围[C , 1.84×C]内即可)。我们的输入保证存在解。

第二行有C\*个整数，表示最小的覆盖子集序号 S1,S2...(子集可以任意序列输出，但不能有重复的数，两个数间用空格隔开)。

##输入样例
12 6<br>
6 0 1 2 3 4 5<br>
4 0 3 6 9<br>
4 1 4 7 10<br>
4 4 5 7 8<br>
4 2 5 8 11<br>
2 9 10<br>

##输出样例
4<br>
0 4 2 1

[评测系统链接](http://acm.xmu.edu.cn/JudgeOnline/problem.php?id=1108)